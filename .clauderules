# Global Claude Code Rules for every project

## Coding Style
- Go with Andrej Karpathy style code in "Minimal Viable Stack": liteweight, only dependencies which are necessary, don't bloat the code!

## Python Environment Management
- **ALWAYS check for virtual environment**: Before any Python operation, verify if `.venv/` exists in project root
- **Auto-activate venv**: If `.venv/` found, prefix all Python commands with `source .venv/bin/activate &&`
- **Use explicit commands**: Always use `python3` (not `python`) and `pip` (not `pip3`) after venv activation
- **Global system protection**: For system-level packages (tkinter, system Python modules), **MUST** ask confirmation before installation
- **Venv creation**: If no `.venv/` exists and Python packages needed, suggest creating one first

## Git & Repository Management  
- **Gitignore verification**: Always ensure `.gitignore` exists and contains essential rules
- **Required gitignore entries**:
  ```
  .venv/
  __pycache__/
  *.pyc
  .env
  .DS_Store
  *.log
  /cache/
  /data/vector_db/
  ```
- **Context-aware additions**: For project-specific files (model weights, processed data), **ASK** before adding to `.gitignore`
- **Gitignore updates**: When suggesting new dependencies/files, proactively check if gitignore needs updates

## File Update Safety Protocol
- **APPEND, DON'T REPLACE**: When updating configuration files, ONLY add missing content
- **PRESERVE EXISTING**: Never delete existing valid configurations
- **EXPLICIT CONFIRMATIONS**: For any destructive operations, explain what will be removed and why
- **INCREMENTAL UPDATES**: Add one logical block at a time, not full replacements

## Dependency & Requirements Management
- Pin exact versions: Always specify exact package versions in requirements.txt (use == not >=) to ensure reproducible builds
- Lock file verification: Before any pip install, check if requirements.txt needs updating; after adding packages, regenerate with `pip freeze >`

## Naming of dirs, objects and entities
- Use clear, concise and logical expressions that tell what is without being too long / complicated
- E.g. name a dir containing py source files - including one scraper module - "src" and NOT "src / module"
- E.g. name a scraper module in a project "EU AI Act Scraper" just "scraper.py" and NOT "eu_ai_act_scraper.py": just scraper is enough here when there is only one scraper module in the project; project name is not necessary within filename, it is derived from context

## Code Quality Standards
- **Type hints mandatory**: All function parameters and return types must have type annotations
- **Error handling**: Wrap external operations (file I/O, API calls, embedding generation) in try/catch blocks
- **Docstrings required**: All public functions must have descriptive docstrings with parameters and return values

## Diverse Coding Rules
### Print vs. Logging
- Stay pythonic be working with print to console statements at crucial steps
- Instead of using logging.error and similar, throw the suitable exceptions
- Only build in logging dependencies / logic if it makes sense to persist data, after confirmation of me
### Let __init__.py files empty
- Let __init__.py files for defining python packages generally empty and only fill them if crucially needed to make the code work


# Claude Code Rules for the specific project
## Priority validity vs. Global rules for every project
- If a rule in this project specific part contradicts rules in the global rules sections, then the project specific rules have priority
##
- 